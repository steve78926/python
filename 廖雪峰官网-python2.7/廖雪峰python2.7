2016-11-15(周二)  上机操作:高级特性： 切片，迭代， 列表生成式 生成器
            上机操作：面向对象编程, 类和实例, 访问限制, 继承和多态, 获取对象信息

2016-11-16(周三):  上机操作：

    高阶函数: 既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数
    map/reduce:
    filter:
    sorted:
    返回函数: 高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回。
        (闭包): 返回闭包时牢记的一点就是：返回函数不要引用任何循环变量，或者后续会发生变化的变量
    匿名函数lambda:
    装饰器:
    偏函数: 简单总结functools.partial的作用就是，把一个函数的某些参数给固定住（也就是设置默认值），返回一个新的函数，调用这个新函数会更简单

2016-11-17(周四): 上机操作:
    模块
    使用模块: 包含sys.argv，它是命令行参数, __name__ == "__main__", 别名import ... as ...， 作用域
    安装第三方模块:  setuptools管理工具， 模块搜索路径：如果我们要添加自己的搜索目录，有两种方法， 一是直接修改sys.path，添加要搜索的目录
                    第二种方法是设置环境变量PYTHONPATH

    使用__future__: Python提供了__future__模块，把下一个新版本的特性导入到当前版本，于是我们就可以在当前版本中测试一些新版本的特性

    面向对象高级编程

    使用__slots__：但动态绑定允许我们在程序运行的过程中动态给class加上功能，这在静态语言中很难实现。
                    为了达到限制的目的，Python允许在定义class的时候，定义一个特殊的__slots__变量，来限制该class能添加的属性

    使用@property： @property，    @score.setter 不是@property.setter,   函数名都是def score()

    多重继承: Mixin  用"混入" 继承其他类, 来获得新的功能. 通过多重继承，一个子类就可以同时获得多个父类的所有功能。
                    只允许单一继承的语言（如Java）不能使用Mixin的设计。

    定制类: __str__, __repr__(), 直接显示变量调用的不是__str__()，而是__repr__(), 解决办法是 _repr__ = __str__. 暂时跳过

    使用元类, 暂时跳过

2016-11-21(周一):
    错误、调试和测试
    错误处理: try...except...finally... , |  可以有多个except来捕获不同类型的错误：| Python所有的错误都是从BaseException类派生的
              finally: 主要用于释放资源，如try 打开文件，finally关闭文件， try打开连接，finally关闭连接
              logging: 可用于记录异常
    抛出错误： raise  下面这句不太理解
                其实这种错误处理方式不但没病，而且相当常见。捕获错误目的只是记录一下，便于后续追踪。但是，由于当前函数不知道应该怎么处理该错误，所以，最恰当的方式是继续往上抛，让顶层调用者去处理。

    ============================
    调试: 第一种方法简单直接粗暴有效，就是用print()把可能有问题的变量打印出来看看：
    断言: 启动Python解释器时可以用-O参数来关闭assert：
    logging: 把print()替换为logging是第3种方式
    pdb: 这个方式似乎不执行，不能进入pdb. 第4种方式是启动Python的调试器pdb，让程序以单步方式运行，可以随时查看运行状态。我们先准备好程序：
    pdb.set_trace():  'module' object has no attribute 'set_trace'

    单元测试
    文档测试:
        Expected: 期待的， Got: 得到的
        **********************************************************************
File "C:\Python27\mydict.py", line 21, in __main__.Dict
Failed example:
    d2.empty
Expected:
    Traceback (most recent call last):
        ...
    AttributeError: 'Dict' object has no attribute 'empty'
Got:
    Traceback (most recent call last):
      File "C:\Python27\lib\doctest.py", line 1315, in __run
        compileflags, 1) in test.globs
      File "<doctest __main__.Dict[8]>", line 1, in <module>
        d2.empty
      File "C:\Python27\mydict.py", line 37, in __getattr__
        raise AttributeError(r"Dict object has no attribute '%s'" % key)
    AttributeError: Dict object has no attribute 'empty'

2016-11-21(周一晚):
    IO编程: 同步和异步的区别就在于是否等待IO执行的结果
    第一种是CPU等着，也就是程序暂停执行后续代码，等100M的数据在10秒后写入磁盘，再接着往下执行，这种模式称为同步IO；
    另一种方法是CPU不等待，只是告诉磁盘，“您老慢慢写，不着急，我接着干别的事去了”，于是，后续代码可以立刻接着执行，这种模式称为异步IO。
    回调模式
    轮询模式

    文件读写: 现代操作系统不允许普通的程序直接操作磁盘，所以，读写文件就是请求操作系统打开一个文件对象（通常称为文件描述符）

    读文件: 要以读文件的模式打开一个文件对象，使用Python内置的open()函数，传入文件名和标示符
    file-like Object:
    二进制文件: 前面讲的默认都是读取文本文件，并且是ASCII编码的文本文件。要读取二进制文件，比如图片、视频等等，用'rb'模式打开文件即可：
    字符编码: 要读取非ASCII编码的文本文件，就必须以二进制模式打开，再解码。比如GBK编码的文件： import codecs
    写文件: 写文件和读文件是一样的，唯一区别是调用open()函数时，传入标识符'w'或者'wb'表示写文本文件或写二进制文件：
















