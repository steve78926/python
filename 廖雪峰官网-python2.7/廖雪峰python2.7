2016-11-15(周二)  上机操作:高级特性： 切片，迭代， 列表生成式 生成器
            上机操作：面向对象编程, 类和实例, 访问限制, 继承和多态, 获取对象信息

2016-11-16(周三):  上机操作：

    高阶函数: 既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数
    map/reduce:
    filter:
    sorted:
    返回函数: 高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回。
        (闭包): 返回闭包时牢记的一点就是：返回函数不要引用任何循环变量，或者后续会发生变化的变量
    匿名函数lambda:
    装饰器:
    偏函数: 简单总结functools.partial的作用就是，把一个函数的某些参数给固定住（也就是设置默认值），返回一个新的函数，调用这个新函数会更简单

2016-11-17(周四): 上机操作:
    模块
    使用模块: 包含sys.argv，它是命令行参数, __name__ == "__main__", 别名import ... as ...， 作用域
    安装第三方模块:  setuptools管理工具， 模块搜索路径：如果我们要添加自己的搜索目录，有两种方法， 一是直接修改sys.path，添加要搜索的目录
                    第二种方法是设置环境变量PYTHONPATH

    使用__future__: Python提供了__future__模块，把下一个新版本的特性导入到当前版本，于是我们就可以在当前版本中测试一些新版本的特性

    面向对象高级编程

    使用__slots__：但动态绑定允许我们在程序运行的过程中动态给class加上功能，这在静态语言中很难实现。
                    为了达到限制的目的，Python允许在定义class的时候，定义一个特殊的__slots__变量，来限制该class能添加的属性

    使用@property： @property，    @score.setter 不是@property.setter,   函数名都是def score()

    多重继承: Mixin  用"混入" 继承其他类, 来获得新的功能. 通过多重继承，一个子类就可以同时获得多个父类的所有功能。
                    只允许单一继承的语言（如Java）不能使用Mixin的设计。

    定制类: __str__, __repr__(), 直接显示变量调用的不是__str__()，而是__repr__(), 解决办法是 _repr__ = __str__. 暂时跳过

    使用元类, 暂时跳过

2016-11-21(周一):
    错误、调试和测试
    错误处理: try...except...finally... , |  可以有多个except来捕获不同类型的错误：| Python所有的错误都是从BaseException类派生的
              finally: 主要用于释放资源，如try 打开文件，finally关闭文件， try打开连接，finally关闭连接
              logging: 可用于记录异常
    抛出错误： raise  下面这句不太理解
                其实这种错误处理方式不但没病，而且相当常见。捕获错误目的只是记录一下，便于后续追踪。但是，由于当前函数不知道应该怎么处理该错误，所以，最恰当的方式是继续往上抛，让顶层调用者去处理。

    ============================
    调试: 第一种方法简单直接粗暴有效，就是用print()把可能有问题的变量打印出来看看：
    断言: 启动Python解释器时可以用-O参数来关闭assert：
    logging: 把print()替换为logging是第3种方式
    pdb: 这个方式似乎不执行，不能进入pdb. 第4种方式是启动Python的调试器pdb，让程序以单步方式运行，可以随时查看运行状态。我们先准备好程序：
    pdb.set_trace():  'module' object has no attribute 'set_trace'

    单元测试
    文档测试:
        Expected: 期待的， Got: 得到的
        **********************************************************************
File "C:\Python27\mydict.py", line 21, in __main__.Dict
Failed example:
    d2.empty
Expected:
    Traceback (most recent call last):
        ...
    AttributeError: 'Dict' object has no attribute 'empty'
Got:
    Traceback (most recent call last):
      File "C:\Python27\lib\doctest.py", line 1315, in __run
        compileflags, 1) in test.globs
      File "<doctest __main__.Dict[8]>", line 1, in <module>
        d2.empty
      File "C:\Python27\mydict.py", line 37, in __getattr__
        raise AttributeError(r"Dict object has no attribute '%s'" % key)
    AttributeError: Dict object has no attribute 'empty'

2016-11-21(周一晚):
    IO编程: 同步和异步的区别就在于是否等待IO执行的结果
        第一种是CPU等着，也就是程序暂停执行后续代码，等100M的数据在10秒后写入磁盘，再接着往下执行，这种模式称为同步IO；
        另一种方法是CPU不等待，只是告诉磁盘，“您老慢慢写，不着急，我接着干别的事去了”，于是，后续代码可以立刻接着执行，这种模式称为异步IO。
        回调模式
        轮询模式

    文件读写: 现代操作系统不允许普通的程序直接操作磁盘，所以，读写文件就是请求操作系统打开一个文件对象（通常称为文件描述符）

        读文件: 要以读文件的模式打开一个文件对象，使用Python内置的open()函数，传入文件名和标示符
        file-like Object:
        二进制文件: 前面讲的默认都是读取文本文件，并且是ASCII编码的文本文件。要读取二进制文件，比如图片、视频等等，用'rb'模式打开文件即可：
        字符编码: 要读取非ASCII编码的文本文件，就必须以二进制模式打开，再解码。比如GBK编码的文件： import codecs
        写文件: 写文件和读文件是一样的，唯一区别是调用open()函数时，传入标识符'w'或者'wb'表示写文本文件或写二进制文件：

    操作文件和目录: import os , os.name
        环境变量: os.environ, os.getenv('PATH')
        操作文件和目录:
                 os.path.abspath('.')
                 os.path.join('/Users/michael', 'testdir')
                 os.path.split('/Users/michael/testdir/file.txt')
                 os.mkdir('/Users/michael/testdir')
                 os.rmdir('/Users/michael/testdir')
                 os.path.splitext('/path/to/file.txt')
                 os.rename('test.txt', 'test.py')
                 os.remove('test.py')
                 这些合并、拆分路径的函数并不要求目录和文件要真实存在，它们只对字符串进行操作。
                 但是复制文件的函数居然在os模块中不存在！原因是复制文件并非由操作系统提供的系统调用
                 shutil模块提供了copyfile()的函数，你还可以在shutil模块中找到很多实用函数，它们可以看做是os模块的补充
                 要注意这些函数有的在os模块中，有的在os.path模块中。

    json: 序列化
        d = dict(name='Bob', age=20, score=88)， pickle.dumps(d)，||||  f = open('dump.txt', 'wb')，pickle.dump(d, f)
        d = dict(name='Bob', age=20, score=88)， json.dumps(d)， json.loads(json_str)

2016-11-22(周二):

    进程和线程
        多进程：os.getpid()
        multiprocessing: from multiprocessing import Process, p = Process(target=run_proc, args=('test',))
        Pool: from multiprocessing import Pool,  p.apply_async(long_time_task, args=(i,))
        进程间通信: from multiprocessing import Process, Queue,

    多线程: 我们前面提到了进程是由若干线程组成的，一个进程至少有一个线程。于线程是操作系统直接支持的执行单元
            由于任何进程默认就会启动一个线程，我们把该线程称为主线程
            Lock: 其次，由于可以存在多个锁，不同的线程持有不同的锁，并试图获取对方持有的锁时，可能会造成死锁，导致多个线程全部挂起，既不能执行，也无法结束，只能靠操作系统强制终止。
            多核CPU: 用C、C++或Java来改写相同的死循环，直接可以把全部核心跑满，4核就跑到400%，8核就跑到800%
                    因为Python的线程虽然是真正的线程，但解释器执行代码时，有一个GIL锁：Global Interpreter Lock，任何Python线程执行前，必须先获得GIL锁，然后，每执行100条字节码，解释器就自动释放GIL锁，让别的线程有机会执行。这个GIL全局锁实际上把所有线程的执行代码都给上了锁，所以，多线程在Python中只能交替执行，即使100个线程跑在100核CPU上，也只能用到1个核
                    Python虽然不能利用多线程实现多核任务，但可以通过多进程实现多核任务。多个Python进程有各自独立的GIL锁，互不影响

            ThreadLocal:  ThreadLocal最常用的地方就是为每个线程绑定一个数据库连接，HTTP请求，用户身份信息等，这样一个线程的所有调用到的处理函数都可以非常方便地访问这些资源。
            进程 vs. 线程:  多进程模式最大的优点就是稳定性高，因为一个子进程崩溃了，不会影响主进程和其他子进程.
                            多进程模式的缺点是创建进程的代价大，在Unix/Linux系统下，用fork调用还行，在Windows下创建进程开销巨大
                            多线程模式致命的缺点就是任何一个线程挂掉都可能直接造成整个进程崩溃，因为所有线程共享进程的内存
                            在Windows下，多线程的效率比多进程要高，所以微软的IIS服务器默认采用多线程模式

                线程切换:   无论是多进程还是多线程，只要数量一多，效率肯定上不去
                计算密集型 vs. IO密集型: 我们可以把任务分为计算密集型和IO密集型
                        要最高效地利用CPU，计算密集型任务同时进行的数量应当等于CPU的核心数
                        Python这样的脚本语言运行效率很低，完全不适合计算密集型任务。对于计算密集型任务，最好用C语言编写。
                        第二种任务的类型是IO密集型，涉及到网络、磁盘IO的任务都是IO密集型任务，这类任务的特点是CPU消耗很少，任务的大部分时间都在等待IO操作完成
                        IO密集型任务执行期间，99%的时间都花在IO上，花在CPU上的时间很少，因此，用运行速度极快的C语言替换用Python这样运行速度极低的脚本语言，完全无法提升运行效率

                异步IO: 现代操作系统对IO操作已经做了巨大的改进，最大的特点就是支持异步IO。如果充分利用操作系统提供的异步IO支持，就可以用单进程单线程模型来执行多任务，这种全新的模型称为事件驱动模型
                        对应到Python语言，单进程的异步编程模型称为协程

                分布式进程:  未看完



























