2016-11-15(周二)  上机操作:高级特性： 切片，迭代， 列表生成式 生成器
            上机操作：面向对象编程, 类和实例, 访问限制, 继承和多态, 获取对象信息

2016-11-16(周三):  上机操作：

    高阶函数: 既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数
    map/reduce:
    filter:
    sorted:
    返回函数: 高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回。
        (闭包): 返回闭包时牢记的一点就是：返回函数不要引用任何循环变量，或者后续会发生变化的变量
    匿名函数lambda:
    装饰器:
    偏函数: 简单总结functools.partial的作用就是，把一个函数的某些参数给固定住（也就是设置默认值），返回一个新的函数，调用这个新函数会更简单

2016-11-17(周四): 上机操作:
    模块
    使用模块: 包含sys.argv，它是命令行参数, __name__ == "__main__", 别名import ... as ...， 作用域
    安装第三方模块:  setuptools管理工具， 模块搜索路径：如果我们要添加自己的搜索目录，有两种方法， 一是直接修改sys.path，添加要搜索的目录
                    第二种方法是设置环境变量PYTHONPATH

    使用__future__: Python提供了__future__模块，把下一个新版本的特性导入到当前版本，于是我们就可以在当前版本中测试一些新版本的特性

    面向对象高级编程

    使用__slots__：但动态绑定允许我们在程序运行的过程中动态给class加上功能，这在静态语言中很难实现。
                    为了达到限制的目的，Python允许在定义class的时候，定义一个特殊的__slots__变量，来限制该class能添加的属性

    使用@property： @property，    @score.setter 不是@property.setter,   函数名都是def score()

    多重继承: Mixin  用"混入" 继承其他类, 来获得新的功能. 通过多重继承，一个子类就可以同时获得多个父类的所有功能。
                    只允许单一继承的语言（如Java）不能使用Mixin的设计。

    定制类: __str__, __repr__(), 直接显示变量调用的不是__str__()，而是__repr__(), 解决办法是 _repr__ = __str__. 暂时跳过

    使用元类, 暂时跳过

2016-11-21(周一):
    错误、调试和测试
    错误处理: try...except...finally... , |  可以有多个except来捕获不同类型的错误：| Python所有的错误都是从BaseException类派生的
              finally: 主要用于释放资源，如try 打开文件，finally关闭文件， try打开连接，finally关闭连接
              logging: 可用于记录异常
    抛出错误： raise  下面这句不太理解
                其实这种错误处理方式不但没病，而且相当常见。捕获错误目的只是记录一下，便于后续追踪。但是，由于当前函数不知道应该怎么处理该错误，所以，最恰当的方式是继续往上抛，让顶层调用者去处理。

    ============================
    调试: 第一种方法简单直接粗暴有效，就是用print()把可能有问题的变量打印出来看看：
    断言: 启动Python解释器时可以用-O参数来关闭assert：
    logging: 把print()替换为logging是第3种方式
    pdb: 这个方式似乎不执行，不能进入pdb. 第4种方式是启动Python的调试器pdb，让程序以单步方式运行，可以随时查看运行状态。我们先准备好程序：
    pdb.set_trace():  'module' object has no attribute 'set_trace'

    单元测试
    文档测试:
















